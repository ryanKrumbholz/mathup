{"ast":null,"code":"const SMALLEST_UNSAFE_INTEGER = 0x20000000000000;\nconst LARGEST_SAFE_INTEGER = SMALLEST_UNSAFE_INTEGER - 1;\nconst UINT32_MAX = -1 >>> 0;\nconst UINT32_SIZE = UINT32_MAX + 1;\nconst INT32_SIZE = UINT32_SIZE / 2;\nconst INT32_MAX = INT32_SIZE - 1;\nconst UINT21_SIZE = 1 << 21;\nconst UINT21_MAX = UINT21_SIZE - 1;\n/**\r\n * Returns a value within [-0x80000000, 0x7fffffff]\r\n */\n\nfunction int32(engine) {\n  return engine.next() | 0;\n}\n\nfunction add(distribution, addend) {\n  if (addend === 0) {\n    return distribution;\n  } else {\n    return engine => distribution(engine) + addend;\n  }\n}\n/**\r\n * Returns a value within [-0x20000000000000, 0x1fffffffffffff]\r\n */\n\n\nfunction int53(engine) {\n  const high = engine.next() | 0;\n  const low = engine.next() >>> 0;\n  return (high & UINT21_MAX) * UINT32_SIZE + low + (high & UINT21_SIZE ? -SMALLEST_UNSAFE_INTEGER : 0);\n}\n/**\r\n * Returns a value within [-0x20000000000000, 0x20000000000000]\r\n */\n\n\nfunction int53Full(engine) {\n  while (true) {\n    const high = engine.next() | 0;\n\n    if (high & 0x400000) {\n      if ((high & 0x7fffff) === 0x400000 && (engine.next() | 0) === 0) {\n        return SMALLEST_UNSAFE_INTEGER;\n      }\n    } else {\n      const low = engine.next() >>> 0;\n      return (high & UINT21_MAX) * UINT32_SIZE + low + (high & UINT21_SIZE ? -SMALLEST_UNSAFE_INTEGER : 0);\n    }\n  }\n}\n/**\r\n * Returns a value within [0, 0xffffffff]\r\n */\n\n\nfunction uint32(engine) {\n  return engine.next() >>> 0;\n}\n/**\r\n * Returns a value within [0, 0x1fffffffffffff]\r\n */\n\n\nfunction uint53(engine) {\n  const high = engine.next() & UINT21_MAX;\n  const low = engine.next() >>> 0;\n  return high * UINT32_SIZE + low;\n}\n/**\r\n * Returns a value within [0, 0x20000000000000]\r\n */\n\n\nfunction uint53Full(engine) {\n  while (true) {\n    const high = engine.next() | 0;\n\n    if (high & UINT21_SIZE) {\n      if ((high & UINT21_MAX) === 0 && (engine.next() | 0) === 0) {\n        return SMALLEST_UNSAFE_INTEGER;\n      }\n    } else {\n      const low = engine.next() >>> 0;\n      return (high & UINT21_MAX) * UINT32_SIZE + low;\n    }\n  }\n}\n\nfunction isPowerOfTwoMinusOne(value) {\n  return (value + 1 & value) === 0;\n}\n\nfunction bitmask(masking) {\n  return engine => engine.next() & masking;\n}\n\nfunction downscaleToLoopCheckedRange(range) {\n  const extendedRange = range + 1;\n  const maximum = extendedRange * Math.floor(UINT32_SIZE / extendedRange);\n  return engine => {\n    let value = 0;\n\n    do {\n      value = engine.next() >>> 0;\n    } while (value >= maximum);\n\n    return value % extendedRange;\n  };\n}\n\nfunction downscaleToRange(range) {\n  if (isPowerOfTwoMinusOne(range)) {\n    return bitmask(range);\n  } else {\n    return downscaleToLoopCheckedRange(range);\n  }\n}\n\nfunction isEvenlyDivisibleByMaxInt32(value) {\n  return (value | 0) === 0;\n}\n\nfunction upscaleWithHighMasking(masking) {\n  return engine => {\n    const high = engine.next() & masking;\n    const low = engine.next() >>> 0;\n    return high * UINT32_SIZE + low;\n  };\n}\n\nfunction upscaleToLoopCheckedRange(extendedRange) {\n  const maximum = extendedRange * Math.floor(SMALLEST_UNSAFE_INTEGER / extendedRange);\n  return engine => {\n    let ret = 0;\n\n    do {\n      const high = engine.next() & UINT21_MAX;\n      const low = engine.next() >>> 0;\n      ret = high * UINT32_SIZE + low;\n    } while (ret >= maximum);\n\n    return ret % extendedRange;\n  };\n}\n\nfunction upscaleWithinU53(range) {\n  const extendedRange = range + 1;\n\n  if (isEvenlyDivisibleByMaxInt32(extendedRange)) {\n    const highRange = (extendedRange / UINT32_SIZE | 0) - 1;\n\n    if (isPowerOfTwoMinusOne(highRange)) {\n      return upscaleWithHighMasking(highRange);\n    }\n  }\n\n  return upscaleToLoopCheckedRange(extendedRange);\n}\n\nfunction upscaleWithinI53AndLoopCheck(min, max) {\n  return engine => {\n    let ret = 0;\n\n    do {\n      const high = engine.next() | 0;\n      const low = engine.next() >>> 0;\n      ret = (high & UINT21_MAX) * UINT32_SIZE + low + (high & UINT21_SIZE ? -SMALLEST_UNSAFE_INTEGER : 0);\n    } while (ret < min || ret > max);\n\n    return ret;\n  };\n}\n/**\r\n * Returns a Distribution to return a value within [min, max]\r\n * @param min The minimum integer value, inclusive. No less than -0x20000000000000.\r\n * @param max The maximum integer value, inclusive. No greater than 0x20000000000000.\r\n */\n\n\nfunction integer(min, max) {\n  min = Math.floor(min);\n  max = Math.floor(max);\n\n  if (min < -SMALLEST_UNSAFE_INTEGER || !isFinite(min)) {\n    throw new RangeError(`Expected min to be at least ${-SMALLEST_UNSAFE_INTEGER}`);\n  } else if (max > SMALLEST_UNSAFE_INTEGER || !isFinite(max)) {\n    throw new RangeError(`Expected max to be at most ${SMALLEST_UNSAFE_INTEGER}`);\n  }\n\n  const range = max - min;\n\n  if (range <= 0 || !isFinite(range)) {\n    return () => min;\n  } else if (range === UINT32_MAX) {\n    if (min === 0) {\n      return uint32;\n    } else {\n      return add(int32, min + INT32_SIZE);\n    }\n  } else if (range < UINT32_MAX) {\n    return add(downscaleToRange(range), min);\n  } else if (range === LARGEST_SAFE_INTEGER) {\n    return add(uint53, min);\n  } else if (range < LARGEST_SAFE_INTEGER) {\n    return add(upscaleWithinU53(range), min);\n  } else if (max - 1 - min === LARGEST_SAFE_INTEGER) {\n    return add(uint53Full, min);\n  } else if (min === -SMALLEST_UNSAFE_INTEGER && max === SMALLEST_UNSAFE_INTEGER) {\n    return int53Full;\n  } else if (min === -SMALLEST_UNSAFE_INTEGER && max === LARGEST_SAFE_INTEGER) {\n    return int53;\n  } else if (min === -LARGEST_SAFE_INTEGER && max === SMALLEST_UNSAFE_INTEGER) {\n    return add(int53, 1);\n  } else if (max === SMALLEST_UNSAFE_INTEGER) {\n    return add(upscaleWithinI53AndLoopCheck(min - 1, max - 1), 1);\n  } else {\n    return upscaleWithinI53AndLoopCheck(min, max);\n  }\n}\n\nfunction isLeastBitTrue(engine) {\n  return (engine.next() & 1) === 1;\n}\n\nfunction lessThan(distribution, value) {\n  return engine => distribution(engine) < value;\n}\n\nfunction probability(percentage) {\n  if (percentage <= 0) {\n    return () => false;\n  } else if (percentage >= 1) {\n    return () => true;\n  } else {\n    const scaled = percentage * UINT32_SIZE;\n\n    if (scaled % 1 === 0) {\n      return lessThan(int32, scaled - INT32_SIZE | 0);\n    } else {\n      return lessThan(uint53, Math.round(percentage * SMALLEST_UNSAFE_INTEGER));\n    }\n  }\n}\n\nfunction bool(numerator, denominator) {\n  if (denominator == null) {\n    if (numerator == null) {\n      return isLeastBitTrue;\n    }\n\n    return probability(numerator);\n  } else {\n    if (numerator <= 0) {\n      return () => false;\n    } else if (numerator >= denominator) {\n      return () => true;\n    }\n\n    return lessThan(integer(0, denominator - 1), numerator);\n  }\n}\n/**\r\n * Returns a Distribution that returns a random `Date` within the inclusive\r\n * range of [`start`, `end`].\r\n * @param start The minimum `Date`\r\n * @param end The maximum `Date`\r\n */\n\n\nfunction date(start, end) {\n  const distribution = integer(+start, +end);\n  return engine => new Date(distribution(engine));\n}\n/**\r\n * Returns a Distribution to return a value within [1, sideCount]\r\n * @param sideCount The number of sides of the die\r\n */\n\n\nfunction die(sideCount) {\n  return integer(1, sideCount);\n}\n/**\r\n * Returns a distribution that returns an array of length `dieCount` of values\r\n * within [1, `sideCount`]\r\n * @param sideCount The number of sides of each die\r\n * @param dieCount The number of dice\r\n */\n\n\nfunction dice(sideCount, dieCount) {\n  const distribution = die(sideCount);\n  return engine => {\n    const result = [];\n\n    for (let i = 0; i < dieCount; ++i) {\n      result.push(distribution(engine));\n    }\n\n    return result;\n  };\n} // tslint:disable:unified-signatures\n// has 2**x chars, for faster uniform distribution\n\n\nconst DEFAULT_STRING_POOL = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-\";\n\nfunction string(pool = DEFAULT_STRING_POOL) {\n  const poolLength = pool.length;\n\n  if (!poolLength) {\n    throw new Error(\"Expected pool not to be an empty string\");\n  }\n\n  const distribution = integer(0, poolLength - 1);\n  return (engine, length) => {\n    let result = \"\";\n\n    for (let i = 0; i < length; ++i) {\n      const j = distribution(engine);\n      result += pool.charAt(j);\n    }\n\n    return result;\n  };\n}\n\nconst LOWER_HEX_POOL = \"0123456789abcdef\";\nconst lowerHex = string(LOWER_HEX_POOL);\nconst upperHex = string(LOWER_HEX_POOL.toUpperCase());\n/**\r\n * Returns a Distribution that returns a random string comprised of numbers\r\n * or the characters `abcdef` (or `ABCDEF`) of length `length`.\r\n * @param length Length of the result string\r\n * @param uppercase Whether the string should use `ABCDEF` instead of `abcdef`\r\n */\n\nfunction hex(uppercase) {\n  if (uppercase) {\n    return upperHex;\n  } else {\n    return lowerHex;\n  }\n}\n\nfunction convertSliceArgument(value, length) {\n  if (value < 0) {\n    return Math.max(value + length, 0);\n  } else {\n    return Math.min(value, length);\n  }\n}\n\nfunction toInteger(value) {\n  const num = +value;\n\n  if (num < 0) {\n    return Math.ceil(num);\n  } else {\n    return Math.floor(num);\n  }\n}\n/**\r\n * Returns a random value within the provided `source` within the sliced\r\n * bounds of `begin` and `end`.\r\n * @param source an array of items to pick from\r\n * @param begin the beginning slice index (defaults to `0`)\r\n * @param end the ending slice index (defaults to `source.length`)\r\n */\n\n\nfunction pick(engine, source, begin, end) {\n  const length = source.length;\n\n  if (length === 0) {\n    throw new RangeError(\"Cannot pick from an empty array\");\n  }\n\n  const start = begin == null ? 0 : convertSliceArgument(toInteger(begin), length);\n  const finish = end === void 0 ? length : convertSliceArgument(toInteger(end), length);\n\n  if (start >= finish) {\n    throw new RangeError(`Cannot pick between bounds ${start} and ${finish}`);\n  }\n\n  const distribution = integer(start, finish - 1);\n  return source[distribution(engine)];\n}\n\nfunction multiply(distribution, multiplier) {\n  if (multiplier === 1) {\n    return distribution;\n  } else if (multiplier === 0) {\n    return () => 0;\n  } else {\n    return engine => distribution(engine) * multiplier;\n  }\n}\n/**\r\n * Returns a floating-point value within [0.0, 1.0)\r\n */\n\n\nfunction realZeroToOneExclusive(engine) {\n  return uint53(engine) / SMALLEST_UNSAFE_INTEGER;\n}\n/**\r\n * Returns a floating-point value within [0.0, 1.0]\r\n */\n\n\nfunction realZeroToOneInclusive(engine) {\n  return uint53Full(engine) / SMALLEST_UNSAFE_INTEGER;\n}\n/**\r\n * Returns a floating-point value within [min, max) or [min, max]\r\n * @param min The minimum floating-point value, inclusive.\r\n * @param max The maximum floating-point value.\r\n * @param inclusive If true, `max` will be inclusive.\r\n */\n\n\nfunction real(min, max, inclusive = false) {\n  if (!isFinite(min)) {\n    throw new RangeError(\"Expected min to be a finite number\");\n  } else if (!isFinite(max)) {\n    throw new RangeError(\"Expected max to be a finite number\");\n  }\n\n  return add(multiply(inclusive ? realZeroToOneInclusive : realZeroToOneExclusive, max - min), min);\n}\n\nconst sliceArray = Array.prototype.slice;\n/**\r\n * Shuffles an array in-place\r\n * @param engine The Engine to use when choosing random values\r\n * @param array The array to shuffle\r\n * @param downTo minimum index to shuffle. Only used internally.\r\n */\n\nfunction shuffle(engine, array, downTo = 0) {\n  const length = array.length;\n\n  if (length) {\n    for (let i = length - 1 >>> 0; i > downTo; --i) {\n      const distribution = integer(0, i);\n      const j = distribution(engine);\n\n      if (i !== j) {\n        const tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n      }\n    }\n  }\n\n  return array;\n}\n/**\r\n * From the population array, produce an array with sampleSize elements that\r\n * are randomly chosen without repeats.\r\n * @param engine The Engine to use when choosing random values\r\n * @param population An array that has items to choose a sample from\r\n * @param sampleSize The size of the result array\r\n */\n\n\nfunction sample(engine, population, sampleSize) {\n  if (sampleSize < 0 || sampleSize > population.length || !isFinite(sampleSize)) {\n    throw new RangeError(\"Expected sampleSize to be within 0 and the length of the population\");\n  }\n\n  if (sampleSize === 0) {\n    return [];\n  }\n\n  const clone = sliceArray.call(population);\n  const length = clone.length;\n\n  if (length === sampleSize) {\n    return shuffle(engine, clone, 0);\n  }\n\n  const tailLength = length - sampleSize;\n  return shuffle(engine, clone, tailLength - 1).slice(tailLength);\n}\n\nconst stringRepeat = (() => {\n  try {\n    if (\"x\".repeat(3) === \"xxx\") {\n      return (pattern, count) => pattern.repeat(count);\n    }\n  } catch (_) {// nothing to do here\n  }\n\n  return (pattern, count) => {\n    let result = \"\";\n\n    while (count > 0) {\n      if (count & 1) {\n        result += pattern;\n      }\n\n      count >>= 1;\n      pattern += pattern;\n    }\n\n    return result;\n  };\n})();\n\nfunction zeroPad(text, zeroCount) {\n  return stringRepeat(\"0\", zeroCount - text.length) + text;\n}\n/**\r\n * Returns a Universally Unique Identifier Version 4.\r\n *\r\n * See http://en.wikipedia.org/wiki/Universally_unique_identifier\r\n */\n\n\nfunction uuid4(engine) {\n  const a = engine.next() >>> 0;\n  const b = engine.next() | 0;\n  const c = engine.next() | 0;\n  const d = engine.next() >>> 0;\n  return zeroPad(a.toString(16), 8) + \"-\" + zeroPad((b & 0xffff).toString(16), 4) + \"-\" + zeroPad((b >> 4 & 0x0fff | 0x4000).toString(16), 4) + \"-\" + zeroPad((c & 0x3fff | 0x8000).toString(16), 4) + \"-\" + zeroPad((c >> 4 & 0xffff).toString(16), 4) + zeroPad(d.toString(16), 8);\n}\n/**\r\n * An int32-producing Engine that uses `Math.random()`\r\n */\n\n\nconst nativeMath = {\n  next() {\n    return Math.random() * UINT32_SIZE | 0;\n  }\n\n}; // tslint:disable:unified-signatures\n\n/**\r\n * A wrapper around an Engine that provides easy-to-use methods for\r\n * producing values based on known distributions\r\n */\n\nclass Random {\n  /**\r\n   * Creates a new Random wrapper\r\n   * @param engine The engine to use (defaults to a `Math.random`-based implementation)\r\n   */\n  constructor(engine = nativeMath) {\n    this.engine = engine;\n  }\n  /**\r\n   * Returns a value within [-0x80000000, 0x7fffffff]\r\n   */\n\n\n  int32() {\n    return int32(this.engine);\n  }\n  /**\r\n   * Returns a value within [0, 0xffffffff]\r\n   */\n\n\n  uint32() {\n    return uint32(this.engine);\n  }\n  /**\r\n   * Returns a value within [0, 0x1fffffffffffff]\r\n   */\n\n\n  uint53() {\n    return uint53(this.engine);\n  }\n  /**\r\n   * Returns a value within [0, 0x20000000000000]\r\n   */\n\n\n  uint53Full() {\n    return uint53Full(this.engine);\n  }\n  /**\r\n   * Returns a value within [-0x20000000000000, 0x1fffffffffffff]\r\n   */\n\n\n  int53() {\n    return int53(this.engine);\n  }\n  /**\r\n   * Returns a value within [-0x20000000000000, 0x20000000000000]\r\n   */\n\n\n  int53Full() {\n    return int53Full(this.engine);\n  }\n  /**\r\n   * Returns a value within [min, max]\r\n   * @param min The minimum integer value, inclusive. No less than -0x20000000000000.\r\n   * @param max The maximum integer value, inclusive. No greater than 0x20000000000000.\r\n   */\n\n\n  integer(min, max) {\n    return integer(min, max)(this.engine);\n  }\n  /**\r\n   * Returns a floating-point value within [0.0, 1.0]\r\n   */\n\n\n  realZeroToOneInclusive() {\n    return realZeroToOneInclusive(this.engine);\n  }\n  /**\r\n   * Returns a floating-point value within [0.0, 1.0)\r\n   */\n\n\n  realZeroToOneExclusive() {\n    return realZeroToOneExclusive(this.engine);\n  }\n  /**\r\n   * Returns a floating-point value within [min, max) or [min, max]\r\n   * @param min The minimum floating-point value, inclusive.\r\n   * @param max The maximum floating-point value.\r\n   * @param inclusive If true, `max` will be inclusive.\r\n   */\n\n\n  real(min, max, inclusive = false) {\n    return real(min, max, inclusive)(this.engine);\n  }\n\n  bool(numerator, denominator) {\n    return bool(numerator, denominator)(this.engine);\n  }\n  /**\r\n   * Return a random value within the provided `source` within the sliced\r\n   * bounds of `begin` and `end`.\r\n   * @param source an array of items to pick from\r\n   * @param begin the beginning slice index (defaults to `0`)\r\n   * @param end the ending slice index (defaults to `source.length`)\r\n   */\n\n\n  pick(source, begin, end) {\n    return pick(this.engine, source, begin, end);\n  }\n  /**\r\n   * Shuffles an array in-place\r\n   * @param array The array to shuffle\r\n   */\n\n\n  shuffle(array) {\n    return shuffle(this.engine, array);\n  }\n  /**\r\n   * From the population array, returns an array with sampleSize elements that\r\n   * are randomly chosen without repeats.\r\n   * @param population An array that has items to choose a sample from\r\n   * @param sampleSize The size of the result array\r\n   */\n\n\n  sample(population, sampleSize) {\n    return sample(this.engine, population, sampleSize);\n  }\n  /**\r\n   * Returns a value within [1, sideCount]\r\n   * @param sideCount The number of sides of the die\r\n   */\n\n\n  die(sideCount) {\n    return die(sideCount)(this.engine);\n  }\n  /**\r\n   * Returns an array of length `dieCount` of values within [1, sideCount]\r\n   * @param sideCount The number of sides of each die\r\n   * @param dieCount The number of dice\r\n   */\n\n\n  dice(sideCount, dieCount) {\n    return dice(sideCount, dieCount)(this.engine);\n  }\n  /**\r\n   * Returns a Universally Unique Identifier Version 4.\r\n   *\r\n   * See http://en.wikipedia.org/wiki/Universally_unique_identifier\r\n   */\n\n\n  uuid4() {\n    return uuid4(this.engine);\n  }\n\n  string(length, pool) {\n    return string(pool)(this.engine, length);\n  }\n  /**\r\n   * Returns a random string comprised of numbers or the characters `abcdef`\r\n   * (or `ABCDEF`) of length `length`.\r\n   * @param length Length of the result string\r\n   * @param uppercase Whether the string should use `ABCDEF` instead of `abcdef`\r\n   */\n\n\n  hex(length, uppercase) {\n    return hex(uppercase)(this.engine, length);\n  }\n  /**\r\n   * Returns a random `Date` within the inclusive range of [`start`, `end`].\r\n   * @param start The minimum `Date`\r\n   * @param end The maximum `Date`\r\n   */\n\n\n  date(start, end) {\n    return date(start, end)(this.engine);\n  }\n\n}\n/**\r\n * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array\r\n */\n\n\nconst I32Array = (() => {\n  try {\n    const buffer = new ArrayBuffer(4);\n    const view = new Int32Array(buffer);\n    view[0] = INT32_SIZE;\n\n    if (view[0] === -INT32_SIZE) {\n      return Int32Array;\n    }\n  } catch (_) {// nothing to do here\n  }\n\n  return Array;\n})();\n\nlet data = null;\nconst COUNT = 128;\nlet index = COUNT;\n/**\r\n * An Engine that relies on the globally-available `crypto.getRandomValues`,\r\n * which is typically available in modern browsers.\r\n *\r\n * See https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues\r\n *\r\n * If unavailable or otherwise non-functioning, then `browserCrypto` will\r\n * likely `throw` on the first call to `next()`.\r\n */\n\nconst browserCrypto = {\n  next() {\n    if (index >= COUNT) {\n      if (data === null) {\n        data = new I32Array(COUNT);\n      }\n\n      crypto.getRandomValues(data);\n      index = 0;\n    }\n\n    return data[index++] | 0;\n  }\n\n};\n/**\r\n * Returns an array of random int32 values, based on current time\r\n * and a random number engine\r\n *\r\n * @param engine an Engine to pull random values from, default `nativeMath`\r\n * @param length the length of the Array, minimum 1, default 16\r\n */\n\nfunction createEntropy(engine = nativeMath, length = 16) {\n  const array = [];\n  array.push(new Date().getTime() | 0);\n\n  for (let i = 1; i < length; ++i) {\n    array[i] = engine.next() | 0;\n  }\n\n  return array;\n}\n/**\r\n * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\r\n */\n\n\nconst imul = (() => {\n  try {\n    if (Math.imul(UINT32_MAX, 5) === -5) {\n      return Math.imul;\n    }\n  } catch (_) {// nothing to do here\n  }\n\n  const UINT16_MAX = 0xffff;\n  return (a, b) => {\n    const ah = a >>> 16 & UINT16_MAX;\n    const al = a & UINT16_MAX;\n    const bh = b >>> 16 & UINT16_MAX;\n    const bl = b & UINT16_MAX; // the shift by 0 fixes the sign on the high part\n    // the final |0 converts the unsigned value into a signed value\n\n    return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;\n  };\n})();\n\nconst ARRAY_SIZE = 624;\nconst ARRAY_MAX = ARRAY_SIZE - 1;\nconst M = 397;\nconst ARRAY_SIZE_MINUS_M = ARRAY_SIZE - M;\nconst A = 0x9908b0df;\n/**\r\n * An Engine that is a pseudorandom number generator using the Mersenne\r\n * Twister algorithm based on the prime 2**19937 âˆ’ 1\r\n *\r\n * See http://en.wikipedia.org/wiki/Mersenne_twister\r\n */\n\nclass MersenneTwister19937 {\n  /**\r\n   * MersenneTwister19937 should not be instantiated directly.\r\n   * Instead, use the static methods `seed`, `seedWithArray`, or `autoSeed`.\r\n   */\n  constructor() {\n    this.data = new I32Array(ARRAY_SIZE);\n    this.index = 0; // integer within [0, 624]\n\n    this.uses = 0;\n  }\n  /**\r\n   * Returns a MersenneTwister19937 seeded with an initial int32 value\r\n   * @param initial the initial seed value\r\n   */\n\n\n  static seed(initial) {\n    return new MersenneTwister19937().seed(initial);\n  }\n  /**\r\n   * Returns a MersenneTwister19937 seeded with zero or more int32 values\r\n   * @param source A series of int32 values\r\n   */\n\n\n  static seedWithArray(source) {\n    return new MersenneTwister19937().seedWithArray(source);\n  }\n  /**\r\n   * Returns a MersenneTwister19937 seeded with the current time and\r\n   * a series of natively-generated random values\r\n   */\n\n\n  static autoSeed() {\n    return MersenneTwister19937.seedWithArray(createEntropy());\n  }\n  /**\r\n   * Returns the next int32 value of the sequence\r\n   */\n\n\n  next() {\n    if ((this.index | 0) >= ARRAY_SIZE) {\n      refreshData(this.data);\n      this.index = 0;\n    }\n\n    const value = this.data[this.index];\n    this.index = this.index + 1 | 0;\n    this.uses += 1;\n    return temper(value) | 0;\n  }\n  /**\r\n   * Returns the number of times that the Engine has been used.\r\n   *\r\n   * This can be provided to an unused MersenneTwister19937 with the same\r\n   * seed, bringing it to the exact point that was left off.\r\n   */\n\n\n  getUseCount() {\n    return this.uses;\n  }\n  /**\r\n   * Discards one or more items from the engine\r\n   * @param count The count of items to discard\r\n   */\n\n\n  discard(count) {\n    if (count <= 0) {\n      return this;\n    }\n\n    this.uses += count;\n\n    if ((this.index | 0) >= ARRAY_SIZE) {\n      refreshData(this.data);\n      this.index = 0;\n    }\n\n    while (count + this.index > ARRAY_SIZE) {\n      count -= ARRAY_SIZE - this.index;\n      refreshData(this.data);\n      this.index = 0;\n    }\n\n    this.index = this.index + count | 0;\n    return this;\n  }\n\n  seed(initial) {\n    let previous = 0;\n    this.data[0] = previous = initial | 0;\n\n    for (let i = 1; i < ARRAY_SIZE; i = i + 1 | 0) {\n      this.data[i] = previous = imul(previous ^ previous >>> 30, 0x6c078965) + i | 0;\n    }\n\n    this.index = ARRAY_SIZE;\n    this.uses = 0;\n    return this;\n  }\n\n  seedWithArray(source) {\n    this.seed(0x012bd6aa);\n    seedWithArray(this.data, source);\n    return this;\n  }\n\n}\n\nfunction refreshData(data) {\n  let k = 0;\n  let tmp = 0;\n\n  for (; (k | 0) < ARRAY_SIZE_MINUS_M; k = k + 1 | 0) {\n    tmp = data[k] & INT32_SIZE | data[k + 1 | 0] & INT32_MAX;\n    data[k] = data[k + M | 0] ^ tmp >>> 1 ^ (tmp & 0x1 ? A : 0);\n  }\n\n  for (; (k | 0) < ARRAY_MAX; k = k + 1 | 0) {\n    tmp = data[k] & INT32_SIZE | data[k + 1 | 0] & INT32_MAX;\n    data[k] = data[k - ARRAY_SIZE_MINUS_M | 0] ^ tmp >>> 1 ^ (tmp & 0x1 ? A : 0);\n  }\n\n  tmp = data[ARRAY_MAX] & INT32_SIZE | data[0] & INT32_MAX;\n  data[ARRAY_MAX] = data[M - 1] ^ tmp >>> 1 ^ (tmp & 0x1 ? A : 0);\n}\n\nfunction temper(value) {\n  value ^= value >>> 11;\n  value ^= value << 7 & 0x9d2c5680;\n  value ^= value << 15 & 0xefc60000;\n  return value ^ value >>> 18;\n}\n\nfunction seedWithArray(data, source) {\n  let i = 1;\n  let j = 0;\n  const sourceLength = source.length;\n  let k = Math.max(sourceLength, ARRAY_SIZE) | 0;\n  let previous = data[0] | 0;\n\n  for (; (k | 0) > 0; --k) {\n    data[i] = previous = (data[i] ^ imul(previous ^ previous >>> 30, 0x0019660d)) + (source[j] | 0) + (j | 0) | 0;\n    i = i + 1 | 0;\n    ++j;\n\n    if ((i | 0) > ARRAY_MAX) {\n      data[0] = data[ARRAY_MAX];\n      i = 1;\n    }\n\n    if (j >= sourceLength) {\n      j = 0;\n    }\n  }\n\n  for (k = ARRAY_MAX; (k | 0) > 0; --k) {\n    data[i] = previous = (data[i] ^ imul(previous ^ previous >>> 30, 0x5d588b65)) - i | 0;\n    i = i + 1 | 0;\n\n    if ((i | 0) > ARRAY_MAX) {\n      data[0] = data[ARRAY_MAX];\n      i = 1;\n    }\n  }\n\n  data[0] = INT32_SIZE;\n}\n\nlet data$1 = null;\nconst COUNT$1 = 128;\nlet index$1 = COUNT$1;\n/**\r\n * An Engine that relies on the node-available\r\n * `require('crypto').randomBytes`, which has been available since 0.58.\r\n *\r\n * See https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback\r\n *\r\n * If unavailable or otherwise non-functioning, then `nodeCrypto` will\r\n * likely `throw` on the first call to `next()`.\r\n */\n\nconst nodeCrypto = {\n  next() {\n    if (index$1 >= COUNT$1) {\n      data$1 = new Int32Array(new Int8Array(require(\"crypto\").randomBytes(4 * COUNT$1)).buffer);\n      index$1 = 0;\n    }\n\n    return data$1[index$1++] | 0;\n  }\n\n};\n/**\r\n * Returns a Distribution to random value within the provided `source`\r\n * within the sliced bounds of `begin` and `end`.\r\n * @param source an array of items to pick from\r\n * @param begin the beginning slice index (defaults to `0`)\r\n * @param end the ending slice index (defaults to `source.length`)\r\n */\n\nfunction picker(source, begin, end) {\n  const clone = sliceArray.call(source, begin, end);\n\n  if (clone.length === 0) {\n    throw new RangeError(`Cannot pick from a source with no items`);\n  }\n\n  const distribution = integer(0, clone.length - 1);\n  return engine => clone[distribution(engine)];\n}\n\nexport { Random, browserCrypto, nativeMath, MersenneTwister19937, nodeCrypto, bool, date, dice, die, hex, int32, int53, int53Full, integer, pick, picker, real, realZeroToOneExclusive, realZeroToOneInclusive, sample, shuffle, string, uint32, uint53, uint53Full, uuid4, createEntropy };","map":{"version":3,"sources":["../src/utils/constants.ts","../src/distribution/int32.ts","../src/utils/add.ts","../src/distribution/int53.ts","../src/distribution/int53Full.ts","../src/distribution/uint32.ts","../src/distribution/uint53.ts","../src/distribution/uint53Full.ts","../src/distribution/integer.ts","../src/distribution/bool.ts","../src/distribution/date.ts","../src/distribution/die.ts","../src/distribution/dice.ts","../src/distribution/string.ts","../src/distribution/hex.ts","../src/utils/convertSliceArgument.ts","../src/utils/toInteger.ts","../src/distribution/pick.ts","../src/utils/multiply.ts","../src/distribution/realZeroToOneExclusive.ts","../src/distribution/realZeroToOneInclusive.ts","../src/distribution/real.ts","../src/utils/sliceArray.ts","../src/distribution/shuffle.ts","../src/distribution/sample.ts","../src/utils/stringRepeat.ts","../src/distribution/uuid4.ts","../src/engine/nativeMath.ts","../src/Random.ts","../src/utils/Int32Array.ts","../src/engine/browserCrypto.ts","../src/utils/createEntropy.ts","../src/utils/imul.ts","../src/engine/MersenneTwister19937.ts","../src/engine/nodeCrypto.ts","../src/distribution/picker.ts"],"names":["Int32Array","data","COUNT","index"],"mappings":"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","sourcesContent":["export const SMALLEST_UNSAFE_INTEGER = 0x20000000000000;\nexport const LARGEST_SAFE_INTEGER = SMALLEST_UNSAFE_INTEGER - 1;\nexport const UINT32_MAX = -1 >>> 0;\nexport const UINT32_SIZE = UINT32_MAX + 1;\nexport const INT32_SIZE = UINT32_SIZE / 2;\nexport const INT32_MAX = INT32_SIZE - 1;\nexport const UINT21_SIZE = 1 << 21;\nexport const UINT21_MAX = UINT21_SIZE - 1;\n","import { Engine } from \"../types\";\n\n/**\n * Returns a value within [-0x80000000, 0x7fffffff]\n */\nexport function int32(engine: Engine): number {\n  return engine.next() | 0;\n}\n","import { Distribution } from \"../types\";\n\nexport function add(distribution: Distribution, addend: number): Distribution {\n  if (addend === 0) {\n    return distribution;\n  } else {\n    return engine => distribution(engine) + addend;\n  }\n}\n","import { Engine } from \"../types\";\nimport {\n  SMALLEST_UNSAFE_INTEGER,\n  UINT21_MAX,\n  UINT21_SIZE,\n  UINT32_SIZE\n} from \"../utils/constants\";\n\n/**\n * Returns a value within [-0x20000000000000, 0x1fffffffffffff]\n */\nexport function int53(engine: Engine): number {\n  const high = engine.next() | 0;\n  const low = engine.next() >>> 0;\n  return (\n    (high & UINT21_MAX) * UINT32_SIZE +\n    low +\n    (high & UINT21_SIZE ? -SMALLEST_UNSAFE_INTEGER : 0)\n  );\n}\n","import { Engine } from \"../types\";\nimport {\n  SMALLEST_UNSAFE_INTEGER,\n  UINT21_MAX,\n  UINT21_SIZE,\n  UINT32_SIZE\n} from \"../utils/constants\";\n\n/**\n * Returns a value within [-0x20000000000000, 0x20000000000000]\n */\nexport function int53Full(engine: Engine): number {\n  while (true) {\n    const high = engine.next() | 0;\n    if (high & 0x400000) {\n      if ((high & 0x7fffff) === 0x400000 && (engine.next() | 0) === 0) {\n        return SMALLEST_UNSAFE_INTEGER;\n      }\n    } else {\n      const low = engine.next() >>> 0;\n      return (\n        (high & UINT21_MAX) * UINT32_SIZE +\n        low +\n        (high & UINT21_SIZE ? -SMALLEST_UNSAFE_INTEGER : 0)\n      );\n    }\n  }\n}\n","import { Engine } from \"../types\";\n\n/**\n * Returns a value within [0, 0xffffffff]\n */\nexport function uint32(engine: Engine): number {\n  return engine.next() >>> 0;\n}\n","import { Engine } from \"../types\";\nimport { UINT21_MAX, UINT32_SIZE } from \"../utils/constants\";\n\n/**\n * Returns a value within [0, 0x1fffffffffffff]\n */\nexport function uint53(engine: Engine): number {\n  const high = engine.next() & UINT21_MAX;\n  const low = engine.next() >>> 0;\n  return high * UINT32_SIZE + low;\n}\n","import { Engine } from \"../types\";\nimport {\n  SMALLEST_UNSAFE_INTEGER,\n  UINT21_MAX,\n  UINT21_SIZE,\n  UINT32_SIZE\n} from \"../utils/constants\";\n\n/**\n * Returns a value within [0, 0x20000000000000]\n */\nexport function uint53Full(engine: Engine): number {\n  while (true) {\n    const high = engine.next() | 0;\n    if (high & UINT21_SIZE) {\n      if ((high & UINT21_MAX) === 0 && (engine.next() | 0) === 0) {\n        return SMALLEST_UNSAFE_INTEGER;\n      }\n    } else {\n      const low = engine.next() >>> 0;\n      return (high & UINT21_MAX) * UINT32_SIZE + low;\n    }\n  }\n}\n","import { Distribution, Engine } from \"../types\";\nimport { add } from \"../utils/add\";\nimport {\n  INT32_SIZE,\n  LARGEST_SAFE_INTEGER,\n  SMALLEST_UNSAFE_INTEGER,\n  UINT21_MAX,\n  UINT21_SIZE,\n  UINT32_MAX,\n  UINT32_SIZE\n} from \"../utils/constants\";\nimport { int32 } from \"./int32\";\nimport { int53 } from \"./int53\";\nimport { int53Full } from \"./int53Full\";\nimport { uint32 } from \"./uint32\";\nimport { uint53 } from \"./uint53\";\nimport { uint53Full } from \"./uint53Full\";\n\nfunction isPowerOfTwoMinusOne(value: number): boolean {\n  return ((value + 1) & value) === 0;\n}\n\nfunction bitmask(masking: number): Distribution {\n  return (engine: Engine) => engine.next() & masking;\n}\n\nfunction downscaleToLoopCheckedRange(range: number): Distribution {\n  const extendedRange = range + 1;\n  const maximum = extendedRange * Math.floor(UINT32_SIZE / extendedRange);\n  return engine => {\n    let value = 0;\n    do {\n      value = engine.next() >>> 0;\n    } while (value >= maximum);\n    return value % extendedRange;\n  };\n}\n\nfunction downscaleToRange(range: number): Distribution {\n  if (isPowerOfTwoMinusOne(range)) {\n    return bitmask(range);\n  } else {\n    return downscaleToLoopCheckedRange(range);\n  }\n}\n\nfunction isEvenlyDivisibleByMaxInt32(value: number): boolean {\n  return (value | 0) === 0;\n}\n\nfunction upscaleWithHighMasking(masking: number): Distribution {\n  return engine => {\n    const high = engine.next() & masking;\n    const low = engine.next() >>> 0;\n    return high * UINT32_SIZE + low;\n  };\n}\n\nfunction upscaleToLoopCheckedRange(extendedRange: number): Distribution {\n  const maximum =\n    extendedRange * Math.floor(SMALLEST_UNSAFE_INTEGER / extendedRange);\n  return engine => {\n    let ret = 0;\n    do {\n      const high = engine.next() & UINT21_MAX;\n      const low = engine.next() >>> 0;\n      ret = high * UINT32_SIZE + low;\n    } while (ret >= maximum);\n    return ret % extendedRange;\n  };\n}\n\nfunction upscaleWithinU53(range: number): Distribution {\n  const extendedRange = range + 1;\n  if (isEvenlyDivisibleByMaxInt32(extendedRange)) {\n    const highRange = ((extendedRange / UINT32_SIZE) | 0) - 1;\n    if (isPowerOfTwoMinusOne(highRange)) {\n      return upscaleWithHighMasking(highRange);\n    }\n  }\n  return upscaleToLoopCheckedRange(extendedRange);\n}\n\nfunction upscaleWithinI53AndLoopCheck(min: number, max: number): Distribution {\n  return engine => {\n    let ret = 0;\n    do {\n      const high = engine.next() | 0;\n      const low = engine.next() >>> 0;\n      ret =\n        (high & UINT21_MAX) * UINT32_SIZE +\n        low +\n        (high & UINT21_SIZE ? -SMALLEST_UNSAFE_INTEGER : 0);\n    } while (ret < min || ret > max);\n    return ret;\n  };\n}\n\n/**\n * Returns a Distribution to return a value within [min, max]\n * @param min The minimum integer value, inclusive. No less than -0x20000000000000.\n * @param max The maximum integer value, inclusive. No greater than 0x20000000000000.\n */\nexport function integer(min: number, max: number): Distribution {\n  min = Math.floor(min);\n  max = Math.floor(max);\n  if (min < -SMALLEST_UNSAFE_INTEGER || !isFinite(min)) {\n    throw new RangeError(\n      `Expected min to be at least ${-SMALLEST_UNSAFE_INTEGER}`\n    );\n  } else if (max > SMALLEST_UNSAFE_INTEGER || !isFinite(max)) {\n    throw new RangeError(\n      `Expected max to be at most ${SMALLEST_UNSAFE_INTEGER}`\n    );\n  }\n\n  const range = max - min;\n  if (range <= 0 || !isFinite(range)) {\n    return () => min;\n  } else if (range === UINT32_MAX) {\n    if (min === 0) {\n      return uint32;\n    } else {\n      return add(int32, min + INT32_SIZE);\n    }\n  } else if (range < UINT32_MAX) {\n    return add(downscaleToRange(range), min);\n  } else if (range === LARGEST_SAFE_INTEGER) {\n    return add(uint53, min);\n  } else if (range < LARGEST_SAFE_INTEGER) {\n    return add(upscaleWithinU53(range), min);\n  } else if (max - 1 - min === LARGEST_SAFE_INTEGER) {\n    return add(uint53Full, min);\n  } else if (\n    min === -SMALLEST_UNSAFE_INTEGER &&\n    max === SMALLEST_UNSAFE_INTEGER\n  ) {\n    return int53Full;\n  } else if (min === -SMALLEST_UNSAFE_INTEGER && max === LARGEST_SAFE_INTEGER) {\n    return int53;\n  } else if (min === -LARGEST_SAFE_INTEGER && max === SMALLEST_UNSAFE_INTEGER) {\n    return add(int53, 1);\n  } else if (max === SMALLEST_UNSAFE_INTEGER) {\n    return add(upscaleWithinI53AndLoopCheck(min - 1, max - 1), 1);\n  } else {\n    return upscaleWithinI53AndLoopCheck(min, max);\n  }\n}\n","import { Distribution, Engine } from \"../types\";\nimport { INT32_SIZE, SMALLEST_UNSAFE_INTEGER, UINT32_SIZE } from \"../utils/constants\";\nimport { int32 } from \"./int32\";\nimport { integer } from \"./integer\";\nimport { uint53 } from \"./uint53\";\n\nfunction isLeastBitTrue(engine: Engine) {\n  return (engine.next() & 1) === 1;\n}\n\nfunction lessThan(\n  distribution: Distribution,\n  value: number\n): Distribution<boolean> {\n  return engine => distribution(engine) < value;\n}\n\nfunction probability(percentage: number) {\n  if (percentage <= 0) {\n    return () => false;\n  } else if (percentage >= 1) {\n    return () => true;\n  } else {\n    const scaled = percentage * UINT32_SIZE;\n    if (scaled % 1 === 0) {\n      return lessThan(int32, (scaled - INT32_SIZE) | 0);\n    } else {\n      return lessThan(uint53, Math.round(percentage * SMALLEST_UNSAFE_INTEGER));\n    }\n  }\n}\n\n// tslint:disable:unified-signatures\n\n/**\n * Returns a boolean Distribution with 50% probability of being true or false\n */\nexport function bool(): Distribution<boolean>;\n/**\n * Returns a boolean Distribution with the provided `percentage` of being true\n * @param percentage A number within [0, 1] of how often the result should be `true`\n */\nexport function bool(percentage: number): Distribution<boolean>;\n/**\n * Returns a boolean Distribution with a probability of\n * `numerator` divided by `denominator` of being true\n * @param numerator The numerator of the probability\n * @param denominator The denominator of the probability\n */\nexport function bool(\n  numerator: number,\n  denominator: number\n): Distribution<boolean>;\nexport function bool(\n  numerator?: number,\n  denominator?: number\n): Distribution<boolean> {\n  if (denominator == null) {\n    if (numerator == null) {\n      return isLeastBitTrue;\n    }\n    return probability(numerator);\n  } else {\n    if (numerator! <= 0) {\n      return () => false;\n    } else if (numerator! >= denominator) {\n      return () => true;\n    }\n    return lessThan(integer(0, denominator - 1), numerator!);\n  }\n}\n","import { Distribution } from \"../types\";\nimport { integer } from \"./integer\";\n\n/**\n * Returns a Distribution that returns a random `Date` within the inclusive\n * range of [`start`, `end`].\n * @param start The minimum `Date`\n * @param end The maximum `Date`\n */\nexport function date(start: Date, end: Date): Distribution<Date> {\n  const distribution = integer(+start, +end);\n  return engine => new Date(distribution(engine));\n}\n","import { Distribution } from \"../types\";\nimport { integer } from \"./integer\";\n\n/**\n * Returns a Distribution to return a value within [1, sideCount]\n * @param sideCount The number of sides of the die\n */\nexport function die(sideCount: number): Distribution<number> {\n  return integer(1, sideCount);\n}\n","import { Distribution } from \"../types\";\nimport { die } from \"./die\";\n\n/**\n * Returns a distribution that returns an array of length `dieCount` of values\n * within [1, `sideCount`]\n * @param sideCount The number of sides of each die\n * @param dieCount The number of dice\n */\nexport function dice(\n  sideCount: number,\n  dieCount: number\n): Distribution<number[]> {\n  const distribution = die(sideCount);\n  return engine => {\n    const result = [];\n    for (let i = 0; i < dieCount; ++i) {\n      result.push(distribution(engine));\n    }\n    return result;\n  };\n}\n","import { StringDistribution } from \"../types\";\nimport { integer } from \"./integer\";\n\n// tslint:disable:unified-signatures\n\n// has 2**x chars, for faster uniform distribution\nconst DEFAULT_STRING_POOL =\n  \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-\";\n\n/**\n * Returns a distribution that returns a random string using numbers,\n * uppercase and lowercase letters, `_`, and `-` of length `length`.\n * @param length Length of the result string\n */\nexport function string(): StringDistribution;\n/**\n * Returns a distribution that returns a random string using the provided\n * string pool as the possible characters to choose from of length `length`.\n * @param length Length of the result string\n */\nexport function string(pool: string): StringDistribution;\nexport function string(pool: string = DEFAULT_STRING_POOL): StringDistribution {\n  const poolLength = pool.length;\n  if (!poolLength) {\n    throw new Error(\"Expected pool not to be an empty string\");\n  }\n\n  const distribution = integer(0, poolLength - 1);\n  return (engine, length) => {\n    let result = \"\";\n    for (let i = 0; i < length; ++i) {\n      const j = distribution(engine);\n      result += pool.charAt(j);\n    }\n    return result;\n  };\n}\n","import { StringDistribution } from \"../types\";\nimport { string } from \"./string\";\n\nconst LOWER_HEX_POOL = \"0123456789abcdef\";\nconst lowerHex = string(LOWER_HEX_POOL);\nconst upperHex = string(LOWER_HEX_POOL.toUpperCase());\n\n/**\n * Returns a Distribution that returns a random string comprised of numbers\n * or the characters `abcdef` (or `ABCDEF`) of length `length`.\n * @param length Length of the result string\n * @param uppercase Whether the string should use `ABCDEF` instead of `abcdef`\n */\nexport function hex(uppercase?: boolean): StringDistribution {\n  if (uppercase) {\n    return upperHex;\n  } else {\n    return lowerHex;\n  }\n}\n","export function convertSliceArgument(value: number, length: number): number {\n  if (value < 0) {\n    return Math.max(value + length, 0);\n  } else {\n    return Math.min(value, length);\n  }\n}\n","export function toInteger(value: number) {\n  const num = +value;\n  if (num < 0) {\n    return Math.ceil(num);\n  } else {\n    return Math.floor(num);\n  }\n}\n","import { Engine } from \"../types\";\nimport { convertSliceArgument } from \"../utils/convertSliceArgument\";\nimport { toInteger } from \"../utils/toInteger\";\nimport { integer } from \"./integer\";\n\n/**\n * Returns a random value within the provided `source` within the sliced\n * bounds of `begin` and `end`.\n * @param source an array of items to pick from\n * @param begin the beginning slice index (defaults to `0`)\n * @param end the ending slice index (defaults to `source.length`)\n */\nexport function pick<T>(\n  engine: Engine,\n  source: ArrayLike<T>,\n  begin?: number,\n  end?: number\n): T {\n  const length = source.length;\n  if (length === 0) {\n    throw new RangeError(\"Cannot pick from an empty array\");\n  }\n  const start =\n    begin == null ? 0 : convertSliceArgument(toInteger(begin), length);\n  const finish =\n    end === void 0 ? length : convertSliceArgument(toInteger(end), length);\n  if (start >= finish) {\n    throw new RangeError(`Cannot pick between bounds ${start} and ${finish}`);\n  }\n  const distribution = integer(start, finish - 1);\n  return source[distribution(engine)];\n}\n","import { Distribution } from \"../types\";\n\nexport function multiply(\n  distribution: Distribution,\n  multiplier: number\n): Distribution {\n  if (multiplier === 1) {\n    return distribution;\n  } else if (multiplier === 0) {\n    return () => 0;\n  } else {\n    return engine => distribution(engine) * multiplier;\n  }\n}\n","import { Engine } from \"../types\";\nimport { SMALLEST_UNSAFE_INTEGER } from \"../utils/constants\";\nimport { uint53 } from \"./uint53\";\n\n/**\n * Returns a floating-point value within [0.0, 1.0)\n */\nexport function realZeroToOneExclusive(engine: Engine): number {\n  return uint53(engine) / SMALLEST_UNSAFE_INTEGER;\n}\n","import { Engine } from \"../types\";\nimport { SMALLEST_UNSAFE_INTEGER } from \"../utils/constants\";\nimport { uint53Full } from \"./uint53Full\";\n\n/**\n * Returns a floating-point value within [0.0, 1.0]\n */\nexport function realZeroToOneInclusive(engine: Engine): number {\n  return uint53Full(engine) / SMALLEST_UNSAFE_INTEGER;\n}\n","import { Distribution } from \"../types\";\nimport { add } from \"../utils/add\";\nimport { multiply } from \"../utils/multiply\";\nimport { realZeroToOneExclusive } from \"./realZeroToOneExclusive\";\nimport { realZeroToOneInclusive } from \"./realZeroToOneInclusive\";\n\n/**\n * Returns a floating-point value within [min, max) or [min, max]\n * @param min The minimum floating-point value, inclusive.\n * @param max The maximum floating-point value.\n * @param inclusive If true, `max` will be inclusive.\n */\nexport function real(\n  min: number,\n  max: number,\n  inclusive: boolean = false\n): Distribution {\n  if (!isFinite(min)) {\n    throw new RangeError(\"Expected min to be a finite number\");\n  } else if (!isFinite(max)) {\n    throw new RangeError(\"Expected max to be a finite number\");\n  }\n  return add(\n    multiply(\n      inclusive ? realZeroToOneInclusive : realZeroToOneExclusive,\n      max - min\n    ),\n    min\n  );\n}\n","export const sliceArray = Array.prototype.slice;\n","import { Engine } from \"../types\";\nimport { integer } from \"./integer\";\n\n/**\n * Shuffles an array in-place\n * @param engine The Engine to use when choosing random values\n * @param array The array to shuffle\n * @param downTo minimum index to shuffle. Only used internally.\n */\nexport function shuffle<T>(\n  engine: Engine,\n  array: T[],\n  downTo: number = 0\n): T[] {\n  const length = array.length;\n  if (length) {\n    for (let i = (length - 1) >>> 0; i > downTo; --i) {\n      const distribution = integer(0, i);\n      const j = distribution(engine);\n      if (i !== j) {\n        const tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n      }\n    }\n  }\n  return array;\n}\n","import { Engine } from \"../types\";\nimport { sliceArray } from \"../utils/sliceArray\";\nimport { shuffle } from \"./shuffle\";\n\n/**\n * From the population array, produce an array with sampleSize elements that\n * are randomly chosen without repeats.\n * @param engine The Engine to use when choosing random values\n * @param population An array that has items to choose a sample from\n * @param sampleSize The size of the result array\n */\nexport function sample<T>(\n  engine: Engine,\n  population: ArrayLike<T>,\n  sampleSize: number\n): T[] {\n  if (\n    sampleSize < 0 ||\n    sampleSize > population.length ||\n    !isFinite(sampleSize)\n  ) {\n    throw new RangeError(\n      \"Expected sampleSize to be within 0 and the length of the population\"\n    );\n  }\n\n  if (sampleSize === 0) {\n    return [];\n  }\n\n  const clone = sliceArray.call(population);\n  const length = clone.length;\n  if (length === sampleSize) {\n    return shuffle(engine, clone, 0);\n  }\n  const tailLength = length - sampleSize;\n  return shuffle(engine, clone, tailLength - 1).slice(tailLength);\n}\n","export const stringRepeat = (() => {\n  try {\n    if ((\"x\" as any).repeat(3) === \"xxx\") {\n      return (pattern: string, count: number): string =>\n        (pattern as any).repeat(count);\n    }\n  } catch (_) {\n    // nothing to do here\n  }\n  return (pattern: string, count: number): string => {\n    let result = \"\";\n    while (count > 0) {\n      if (count & 1) {\n        result += pattern;\n      }\n      count >>= 1;\n      pattern += pattern;\n    }\n    return result;\n  };\n})();\n","import { Engine } from \"../types\";\nimport { stringRepeat } from \"../utils/stringRepeat\";\n\nfunction zeroPad(text: string, zeroCount: number) {\n  return stringRepeat(\"0\", zeroCount - text.length) + text;\n}\n\n/**\n * Returns a Universally Unique Identifier Version 4.\n *\n * See http://en.wikipedia.org/wiki/Universally_unique_identifier\n */\nexport function uuid4(engine: Engine) {\n  const a = engine.next() >>> 0;\n  const b = engine.next() | 0;\n  const c = engine.next() | 0;\n  const d = engine.next() >>> 0;\n\n  return (\n    zeroPad(a.toString(16), 8) +\n    \"-\" +\n    zeroPad((b & 0xffff).toString(16), 4) +\n    \"-\" +\n    zeroPad((((b >> 4) & 0x0fff) | 0x4000).toString(16), 4) +\n    \"-\" +\n    zeroPad(((c & 0x3fff) | 0x8000).toString(16), 4) +\n    \"-\" +\n    zeroPad(((c >> 4) & 0xffff).toString(16), 4) +\n    zeroPad(d.toString(16), 8)\n  );\n}\n","import { Engine } from \"../types\";\nimport { UINT32_SIZE } from \"../utils/constants\";\n\n/**\n * An int32-producing Engine that uses `Math.random()`\n */\nexport const nativeMath: Engine = {\n  next() {\n    return (Math.random() * UINT32_SIZE) | 0;\n  }\n};\n","import { bool } from \"./distribution/bool\";\nimport { date } from \"./distribution/date\";\nimport { dice } from \"./distribution/dice\";\nimport { die } from \"./distribution/die\";\nimport { hex } from \"./distribution/hex\";\nimport { int32 } from \"./distribution/int32\";\nimport { int53 } from \"./distribution/int53\";\nimport { int53Full } from \"./distribution/int53Full\";\nimport { integer } from \"./distribution/integer\";\nimport { pick } from \"./distribution/pick\";\nimport { real } from \"./distribution/real\";\nimport { realZeroToOneExclusive } from \"./distribution/realZeroToOneExclusive\";\nimport { realZeroToOneInclusive } from \"./distribution/realZeroToOneInclusive\";\nimport { sample } from \"./distribution/sample\";\nimport { shuffle } from \"./distribution/shuffle\";\nimport { string } from \"./distribution/string\";\nimport { uint32 } from \"./distribution/uint32\";\nimport { uint53 } from \"./distribution/uint53\";\nimport { uint53Full } from \"./distribution/uint53Full\";\nimport { uuid4 } from \"./distribution/uuid4\";\nimport { nativeMath } from \"./engine/nativeMath\";\nimport { Engine } from \"./types\";\n\n// tslint:disable:unified-signatures\n\n/**\n * A wrapper around an Engine that provides easy-to-use methods for\n * producing values based on known distributions\n */\nexport class Random {\n  private readonly engine: Engine;\n\n  /**\n   * Creates a new Random wrapper\n   * @param engine The engine to use (defaults to a `Math.random`-based implementation)\n   */\n  constructor(engine: Engine = nativeMath) {\n    this.engine = engine;\n  }\n\n  /**\n   * Returns a value within [-0x80000000, 0x7fffffff]\n   */\n  public int32(): number {\n    return int32(this.engine);\n  }\n\n  /**\n   * Returns a value within [0, 0xffffffff]\n   */\n  public uint32(): number {\n    return uint32(this.engine);\n  }\n\n  /**\n   * Returns a value within [0, 0x1fffffffffffff]\n   */\n  public uint53(): number {\n    return uint53(this.engine);\n  }\n\n  /**\n   * Returns a value within [0, 0x20000000000000]\n   */\n  public uint53Full(): number {\n    return uint53Full(this.engine);\n  }\n\n  /**\n   * Returns a value within [-0x20000000000000, 0x1fffffffffffff]\n   */\n  public int53(): number {\n    return int53(this.engine);\n  }\n\n  /**\n   * Returns a value within [-0x20000000000000, 0x20000000000000]\n   */\n  public int53Full(): number {\n    return int53Full(this.engine);\n  }\n\n  /**\n   * Returns a value within [min, max]\n   * @param min The minimum integer value, inclusive. No less than -0x20000000000000.\n   * @param max The maximum integer value, inclusive. No greater than 0x20000000000000.\n   */\n  public integer(min: number, max: number): number {\n    return integer(min, max)(this.engine);\n  }\n\n  /**\n   * Returns a floating-point value within [0.0, 1.0]\n   */\n  public realZeroToOneInclusive(): number {\n    return realZeroToOneInclusive(this.engine);\n  }\n\n  /**\n   * Returns a floating-point value within [0.0, 1.0)\n   */\n  public realZeroToOneExclusive(): number {\n    return realZeroToOneExclusive(this.engine);\n  }\n\n  /**\n   * Returns a floating-point value within [min, max) or [min, max]\n   * @param min The minimum floating-point value, inclusive.\n   * @param max The maximum floating-point value.\n   * @param inclusive If true, `max` will be inclusive.\n   */\n  public real(min: number, max: number, inclusive: boolean = false): number {\n    return real(min, max, inclusive)(this.engine);\n  }\n\n  /**\n   * Returns a boolean with 50% probability of being true or false\n   */\n  public bool(): boolean;\n  /**\n   * Returns a boolean with the provided `percentage` of being true\n   * @param percentage A number within [0, 1] of how often the result should be `true`\n   */\n  public bool(percentage: number): boolean;\n  /**\n   * Returns a boolean with a probability of `numerator`/`denominator` of being true\n   * @param numerator The numerator of the probability\n   * @param denominator The denominator of the probability\n   */\n  public bool(numerator: number, denominator: number): boolean;\n  public bool(numerator?: number, denominator?: number): boolean {\n    return bool(numerator!, denominator!)(this.engine);\n  }\n\n  /**\n   * Return a random value within the provided `source` within the sliced\n   * bounds of `begin` and `end`.\n   * @param source an array of items to pick from\n   * @param begin the beginning slice index (defaults to `0`)\n   * @param end the ending slice index (defaults to `source.length`)\n   */\n  public pick<T>(source: ArrayLike<T>, begin?: number, end?: number): T {\n    return pick(this.engine, source, begin, end);\n  }\n\n  /**\n   * Shuffles an array in-place\n   * @param array The array to shuffle\n   */\n  public shuffle<T>(array: T[]): T[] {\n    return shuffle(this.engine, array);\n  }\n\n  /**\n   * From the population array, returns an array with sampleSize elements that\n   * are randomly chosen without repeats.\n   * @param population An array that has items to choose a sample from\n   * @param sampleSize The size of the result array\n   */\n  public sample<T>(population: ArrayLike<T>, sampleSize: number): T[] {\n    return sample(this.engine, population, sampleSize);\n  }\n\n  /**\n   * Returns a value within [1, sideCount]\n   * @param sideCount The number of sides of the die\n   */\n  public die(sideCount: number): number {\n    return die(sideCount)(this.engine);\n  }\n\n  /**\n   * Returns an array of length `dieCount` of values within [1, sideCount]\n   * @param sideCount The number of sides of each die\n   * @param dieCount The number of dice\n   */\n  public dice(sideCount: number, dieCount: number): number[] {\n    return dice(sideCount, dieCount)(this.engine);\n  }\n\n  /**\n   * Returns a Universally Unique Identifier Version 4.\n   *\n   * See http://en.wikipedia.org/wiki/Universally_unique_identifier\n   */\n  public uuid4(): string {\n    return uuid4(this.engine);\n  }\n\n  /**\n   * Returns a random string using numbers, uppercase and lowercase letters,\n   * `_`, and `-` of length `length`.\n   * @param length Length of the result string\n   */\n  public string(length: number): string;\n  /**\n   * Returns a random string using the provided string pool as the possible\n   * characters to choose from of length `length`.\n   * @param length Length of the result string\n   */\n  public string(length: number, pool: string): string;\n  public string(length: number, pool?: string): string {\n    return string(pool!)(this.engine, length);\n  }\n\n  /**\n   * Returns a random string comprised of numbers or the characters `abcdef`\n   * (or `ABCDEF`) of length `length`.\n   * @param length Length of the result string\n   * @param uppercase Whether the string should use `ABCDEF` instead of `abcdef`\n   */\n  public hex(length: number, uppercase?: boolean): string {\n    return hex(uppercase)(this.engine, length);\n  }\n\n  /**\n   * Returns a random `Date` within the inclusive range of [`start`, `end`].\n   * @param start The minimum `Date`\n   * @param end The maximum `Date`\n   */\n  public date(start: Date, end: Date): Date {\n    return date(start, end)(this.engine);\n  }\n}\n","import { INT32_SIZE } from \"./constants\";\n\n/**\n * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array\n */\nconst I32Array: typeof Int32Array = (() => {\n  try {\n    const buffer = new ArrayBuffer(4);\n    const view = new Int32Array(buffer);\n    view[0] = INT32_SIZE;\n    if (view[0] === -INT32_SIZE) {\n      return Int32Array;\n    }\n  } catch (_) {\n    // nothing to do here\n  }\n  return (Array as unknown) as typeof Int32Array;\n})();\nexport { I32Array as Int32Array };\n","import { Engine } from \"../types\";\nimport { Int32Array } from \"../utils/Int32Array\";\n\nlet data: Int32Array | null = null;\nconst COUNT = 128;\nlet index = COUNT;\n\n/**\n * An Engine that relies on the globally-available `crypto.getRandomValues`,\n * which is typically available in modern browsers.\n *\n * See https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues\n *\n * If unavailable or otherwise non-functioning, then `browserCrypto` will\n * likely `throw` on the first call to `next()`.\n */\nexport const browserCrypto: Engine = {\n  next() {\n    if (index >= COUNT) {\n      if (data === null) {\n        data = new Int32Array(COUNT);\n      }\n      crypto.getRandomValues(data);\n      index = 0;\n    }\n    return data![index++] | 0;\n  }\n};\n","import { nativeMath } from \"../engine/nativeMath\";\nimport { Engine } from \"../types\";\n\n/**\n * Returns an array of random int32 values, based on current time\n * and a random number engine\n *\n * @param engine an Engine to pull random values from, default `nativeMath`\n * @param length the length of the Array, minimum 1, default 16\n */\nexport function createEntropy(\n  engine: Engine = nativeMath,\n  length: number = 16\n): number[] {\n  const array: number[] = [];\n  array.push(new Date().getTime() | 0);\n  for (let i = 1; i < length; ++i) {\n    array[i] = engine.next() | 0;\n  }\n  return array;\n}\n","import { UINT32_MAX } from \"./constants\";\n\n/**\n * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\n */\nexport const imul: (a: number, b: number) => number = (() => {\n  try {\n    if ((Math as any).imul(UINT32_MAX, 5) === -5) {\n      return (Math as any).imul;\n    }\n  } catch (_) {\n    // nothing to do here\n  }\n  const UINT16_MAX = 0xffff;\n  return (a: number, b: number) => {\n    const ah = (a >>> 16) & UINT16_MAX;\n    const al = a & UINT16_MAX;\n    const bh = (b >>> 16) & UINT16_MAX;\n    const bl = b & UINT16_MAX;\n    // the shift by 0 fixes the sign on the high part\n    // the final |0 converts the unsigned value into a signed value\n    return (al * bl + (((ah * bl + al * bh) << 16) >>> 0)) | 0;\n  };\n})();\n","import { Engine } from \"../types\";\nimport { INT32_MAX, INT32_SIZE } from \"../utils/constants\";\nimport { createEntropy } from \"../utils/createEntropy\";\nimport { imul } from \"../utils/imul\";\nimport { Int32Array } from \"../utils/Int32Array\";\n\nconst ARRAY_SIZE = 624;\nconst ARRAY_MAX = ARRAY_SIZE - 1;\nconst M = 397;\nconst ARRAY_SIZE_MINUS_M = ARRAY_SIZE - M;\nconst A = 0x9908b0df;\n\n/**\n * An Engine that is a pseudorandom number generator using the Mersenne\n * Twister algorithm based on the prime 2**19937 âˆ’ 1\n *\n * See http://en.wikipedia.org/wiki/Mersenne_twister\n */\nexport class MersenneTwister19937 implements Engine {\n  /**\n   * Returns a MersenneTwister19937 seeded with an initial int32 value\n   * @param initial the initial seed value\n   */\n  public static seed(initial: number): MersenneTwister19937 {\n    return new MersenneTwister19937().seed(initial);\n  }\n\n  /**\n   * Returns a MersenneTwister19937 seeded with zero or more int32 values\n   * @param source A series of int32 values\n   */\n  public static seedWithArray(source: ArrayLike<number>): MersenneTwister19937 {\n    return new MersenneTwister19937().seedWithArray(source);\n  }\n\n  /**\n   * Returns a MersenneTwister19937 seeded with the current time and\n   * a series of natively-generated random values\n   */\n  public static autoSeed(): MersenneTwister19937 {\n    return MersenneTwister19937.seedWithArray(createEntropy());\n  }\n\n  private readonly data = new Int32Array(ARRAY_SIZE);\n  private index = 0; // integer within [0, 624]\n  private uses = 0;\n\n  /**\n   * MersenneTwister19937 should not be instantiated directly.\n   * Instead, use the static methods `seed`, `seedWithArray`, or `autoSeed`.\n   */\n  private constructor() {}\n\n  /**\n   * Returns the next int32 value of the sequence\n   */\n  public next(): number {\n    if ((this.index | 0) >= ARRAY_SIZE) {\n      refreshData(this.data);\n      this.index = 0;\n    }\n\n    const value = this.data[this.index];\n    this.index = (this.index + 1) | 0;\n    this.uses += 1;\n    return temper(value) | 0;\n  }\n\n  /**\n   * Returns the number of times that the Engine has been used.\n   *\n   * This can be provided to an unused MersenneTwister19937 with the same\n   * seed, bringing it to the exact point that was left off.\n   */\n  public getUseCount(): number {\n    return this.uses;\n  }\n\n  /**\n   * Discards one or more items from the engine\n   * @param count The count of items to discard\n   */\n  public discard(count: number): this {\n    if (count <= 0) {\n      return this;\n    }\n    this.uses += count;\n    if ((this.index | 0) >= ARRAY_SIZE) {\n      refreshData(this.data);\n      this.index = 0;\n    }\n    while (count + this.index > ARRAY_SIZE) {\n      count -= ARRAY_SIZE - this.index;\n      refreshData(this.data);\n      this.index = 0;\n    }\n    this.index = (this.index + count) | 0;\n    return this;\n  }\n\n  private seed(initial: number): this {\n    let previous = 0;\n    this.data[0] = previous = initial | 0;\n\n    for (let i = 1; i < ARRAY_SIZE; i = (i + 1) | 0) {\n      this.data[i] = previous =\n        (imul(previous ^ (previous >>> 30), 0x6c078965) + i) | 0;\n    }\n    this.index = ARRAY_SIZE;\n    this.uses = 0;\n    return this;\n  }\n\n  private seedWithArray(source: ArrayLike<number>): this {\n    this.seed(0x012bd6aa);\n    seedWithArray(this.data, source);\n    return this;\n  }\n}\n\nfunction refreshData(data: Int32Array) {\n  let k = 0;\n  let tmp = 0;\n  for (; (k | 0) < ARRAY_SIZE_MINUS_M; k = (k + 1) | 0) {\n    tmp = (data[k] & INT32_SIZE) | (data[(k + 1) | 0] & INT32_MAX);\n    data[k] = data[(k + M) | 0] ^ (tmp >>> 1) ^ (tmp & 0x1 ? A : 0);\n  }\n\n  for (; (k | 0) < ARRAY_MAX; k = (k + 1) | 0) {\n    tmp = (data[k] & INT32_SIZE) | (data[(k + 1) | 0] & INT32_MAX);\n    data[k] =\n      data[(k - ARRAY_SIZE_MINUS_M) | 0] ^ (tmp >>> 1) ^ (tmp & 0x1 ? A : 0);\n  }\n\n  tmp = (data[ARRAY_MAX] & INT32_SIZE) | (data[0] & INT32_MAX);\n  data[ARRAY_MAX] = data[M - 1] ^ (tmp >>> 1) ^ (tmp & 0x1 ? A : 0);\n}\n\nfunction temper(value: number) {\n  value ^= value >>> 11;\n  value ^= (value << 7) & 0x9d2c5680;\n  value ^= (value << 15) & 0xefc60000;\n  return value ^ (value >>> 18);\n}\n\nfunction seedWithArray(data: Int32Array, source: ArrayLike<number>) {\n  let i = 1;\n  let j = 0;\n  const sourceLength = source.length;\n  let k = Math.max(sourceLength, ARRAY_SIZE) | 0;\n  let previous = data[0] | 0;\n  for (; (k | 0) > 0; --k) {\n    data[i] = previous =\n      ((data[i] ^ imul(previous ^ (previous >>> 30), 0x0019660d)) +\n        (source[j] | 0) +\n        (j | 0)) |\n      0;\n    i = (i + 1) | 0;\n    ++j;\n    if ((i | 0) > ARRAY_MAX) {\n      data[0] = data[ARRAY_MAX];\n      i = 1;\n    }\n    if (j >= sourceLength) {\n      j = 0;\n    }\n  }\n  for (k = ARRAY_MAX; (k | 0) > 0; --k) {\n    data[i] = previous =\n      ((data[i] ^ imul(previous ^ (previous >>> 30), 0x5d588b65)) - i) | 0;\n    i = (i + 1) | 0;\n    if ((i | 0) > ARRAY_MAX) {\n      data[0] = data[ARRAY_MAX];\n      i = 1;\n    }\n  }\n  data[0] = INT32_SIZE;\n}\n","import { Engine } from \"../types\";\n\nlet data: Int32Array | null = null;\nconst COUNT = 128;\nlet index = COUNT;\n\n/**\n * An Engine that relies on the node-available\n * `require('crypto').randomBytes`, which has been available since 0.58.\n *\n * See https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback\n *\n * If unavailable or otherwise non-functioning, then `nodeCrypto` will\n * likely `throw` on the first call to `next()`.\n */\nexport const nodeCrypto: Engine = {\n  next() {\n    if (index >= COUNT) {\n      data = new Int32Array(\n        new Int8Array(require(\"crypto\").randomBytes(4 * COUNT)).buffer\n      );\n      index = 0;\n    }\n    return data![index++] | 0;\n  }\n};\n","import { Distribution } from \"../types\";\nimport { sliceArray } from \"../utils/sliceArray\";\nimport { integer } from \"./integer\";\n\n/**\n * Returns a Distribution to random value within the provided `source`\n * within the sliced bounds of `begin` and `end`.\n * @param source an array of items to pick from\n * @param begin the beginning slice index (defaults to `0`)\n * @param end the ending slice index (defaults to `source.length`)\n */\nexport function picker<T>(\n  source: ArrayLike<T>,\n  begin?: number,\n  end?: number\n): Distribution<T> {\n  const clone = sliceArray.call(source, begin, end);\n  if (clone.length === 0) {\n    throw new RangeError(`Cannot pick from a source with no items`);\n  }\n  const distribution = integer(0, clone.length - 1);\n  return engine => clone[distribution(engine)];\n}\n"]},"metadata":{},"sourceType":"module"}